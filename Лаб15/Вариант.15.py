import time  # Импорт модуля для работы со временем
import random  # Импорт модуля для генерации случайных чисел
from functools import wraps  # Импорт функции wraps из модуля functools для сохранения метаданных

# Декоратор для измерения времени выполнения
def timeit(method):
    @wraps(method)  # Применяем декоратор wraps к методу
    def timed(*args, **kw):  # Создаем функцию timed, которая будет измерять время выполнения метода
        ts = time.monotonic()  # Записываем текущее время в переменную ts
        result = method(*args, **kw)  # Вызываем метод, для которого нужно измерить время выполнения
        te = time.monotonic()  # Записываем текущее время в переменную te
        ms = (te - ts) * 1000  # Подсчет времени выполнения в миллисекундах
        return result, ms  # Возвращаем результат выполнения функции и время выполнения
    return timed  # Возвращаем  функцию

@timeit  # Применяем декоратор timeit к функции bu()
def bu(arr):  # Определение функции для сортировки
    n = len(arr)  # Определяем длину списка
    for i in range(n):  # Внешний цикл для проходов по массиву
        for j in range(0, n-i-1):  # Внутренний цикл для сравнения и обмена элементов
            if arr[j] > arr[j+1]:  # Если текущий элемент больше следующего
                arr[j], arr[j+1] = arr[j+1], arr[j]  # Меняем их местами
    return arr  # Возвращаем отсортированный массив

sizes = [10, 100, 1000, 10000]  # Задаем массив различных размеров для теста сортировки

# Выводим заголовок таблицы с результатами
print("| № | Кол-во элементов | Отсортированный список | Время выполнения (ms) |")
# Цикл для тестирования разных размеров массивов и вывода результатов
for i, size in enumerate(sizes, 1):
    arr = [random.randint(0, 100) for _ in range(size)]  # Генерируем случайный массив указанной длины
    result, timing = bu(arr.copy())  # Сортируем его и замеряем время выполнения
    print(f"| {i} | {size} | {result} | {timing:.2f} |")  # Выводим результаты









